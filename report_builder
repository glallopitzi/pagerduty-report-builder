#!/bin/bash
# ------------------------------------------------------------------
# [gianc] report_builder
#          Description
# ------------------------------------------------------------------

VERSION=0.1.0
SUBJECT=report_builder

USAGE="Usage: report_builder [getAll|parse|list|details INCIDENT_ID|setup ENV|clean]"

# --- Options processing -------------------------------------------
if [ $# == 0 ] ; then
    echo $USAGE
    exit 1;
fi

###########################################

# set some variables
source common_variables

# include parser
source parser

function getAllIncidentsNew {

	INCIDENTS_REMAINED=1000
	TOTAL_REQUESTED=0
	
	LIMIT_KEY="--data-urlencode limit="
	LIMIT_VALUE=100
	ITERATION_LIMIT="$LIMIT_KEY$LIMIT_VALUE"

	OFFSET_KEY="--data-urlencode offset="
	OFFSET_VALUE=0
	ITERATION_OFFSET="$OFFSET_KEY$OFFSET_VALUE"

	writeLine
	logMsg "getAllIncidentsNew|BEGIN"
	echo 

	ITERATION_COUNTER=1
	while [ $INCIDENTS_REMAINED -gt 0 ] && [ $ITERATION_COUNTER -lt 10 ]; do
		writeLine
		echo "interation $ITERATION_COUNTER BEGIN"

		curl -H $HEADER --basic --user $AUTH -X GET -G $SINCE $UNTIL $FIELD $ITERATION_LIMIT $ITERATION_OFFSET $BASEURL/incidents > $AUX_RESULT

		TOTAL_REQ=`cat $AUX_RESULT | ./jq '.total'`
		LIMIT_REQ=`cat $AUX_RESULT | ./jq '.limit'`
		OFFSET_REQ=`cat $AUX_RESULT | ./jq '.offset'`

		logMsg "total req: $TOTAL_REQ"
		logMsg "offset req: $OFFSET_REQ"
		logMsg "limit req: $LIMIT_REQ"

		cat $AUX_RESULT | ./jq '.incidents[].id' | sed -e 's/^"//'  -e 's/"$//' >> $RESULT_INCIDENTS_ID
		cat $AUX_RESULT | ./jq '.incidents[].incident_number' >> $RESULT_INCIDENTS_NUMBER

		writeLine
		echo "interation $ITERATION_COUNTER END"
		echo 

		# some loop vars update
		OFFSET_VALUE=$((OFFSET_VALUE + LIMIT_VALUE))
		ITERATION_OFFSET="$OFFSET_KEY$OFFSET_VALUE"
		ITERATION_COUNTER=$((ITERATION_COUNTER+1))
		INCIDENTS_REMAINED=$((TOTAL_REQ - ( OFFSET_REQ + LIMIT_REQ )))
	done

	echo
	writeLine
	echo "clean results.."
	sed 's/\"//g' $RESULT_INCIDENTS_ID
	sed 's/\"//g' $RESULT_INCIDENTS_NUMBER
	writeLine
	echo
	
	rm $AUX_RESULT

	echo "getAllIncidentsNew|END"
}

function getAllIncidents {
	writeLine
	echo "getting list of incidents.."
	curl -H $HEADER --basic --user $AUTH -X GET -G $SINCE $UNTIL $FIELD $BASEURL/incidents > $TMP_GLOBAL_RESULT	
	echo "list of incidents response saved in $TMP_GLOBAL_RESULT file"
}

function getSingleIncident {
	writeLine
	echo "getting details for incident with id: $1" 
	curl -H $HEADER --basic --user $AUTH -X GET -G $BASEURL/incidents/$1/log_entries > $TMP_SINGLE_RESULT
	echo "details response for incident with id: $1 saved in $TMP_SINGLE_RESULT file" 
}

function parseSingleIncidentNew {
	echo "try to parse single incident with number: $1"
	hasMoreLogs=0
	logIndex=0

	# info to get from logs for each incident
	INCIDENT_NUMBER=$1

	INCIDENT_HOST=""
	INCIDENT_HOST_FLAG=0

	ACK_ON=""
	ACK_ON_FLAG=0

	RESOLVED_OR_ESCALATED_ON=""
	RESOLVED_OR_ESCALATED_ON_FLAG=0

	while [ $logIndex -lt 20 ] && [ $hasMoreLogs -eq 0 ]; do

		ITEM=`cat $TMP_SINGLE_RESULT | ./jq '.log_entries['$logIndex'].type'`
		
		if [ "$ITEM" != '' ] && [ "$ITEM" != 'null' ]; then
			ITEM=`sed 's/\"//g' <<< $ITEM`
			#echo "evaluating $ITEM.."

			case $ITEM in
			    'trigger' )
					#echo "found trigger"
					if [ $INCIDENT_HOST_FLAG -eq 0 ]; then
						INCIDENT_HOST=`cat $TMP_SINGLE_RESULT | ./jq '.log_entries['$logIndex'].channel.summary'`
						if [ "$INCIDENT_HOST" != '' ] && [ "$INCIDENT_HOST" != 'null' ]; then
							INCIDENT_HOST_FLAG=1
						fi
					fi        
			        ;;

			    'assign'|'acknowledge' )
					#echo "found acknowledge"
					if [ $ACK_ON_FLAG -eq 0 ]; then
						ACK_ON=`cat $TMP_SINGLE_RESULT | ./jq '.log_entries['$logIndex'].created_at'`
						ACK_ON_FLAG=1
					fi
			        ;;

			    'escalate'|'resolve' )
					#echo "found resolved or escalated"
					if [ $RESOLVED_OR_ESCALATED_ON_FLAG -eq 0 ]; then
						RESOLVED_OR_ESCALATED_ON=`cat $TMP_SINGLE_RESULT | ./jq '.log_entries['$logIndex'].created_at'`
						RESOLVED_OR_ESCALATED_ON_FLAG=1
					fi
			        ;;
			esac
		else
			#echo "no more logs"
			hasMoreLogs=1
		fi
		logIndex=$(( $logIndex + 1 ))
	done

	writeLine
	echo "INCIDENT_NUMBER: $INCIDENT_NUMBER"
	echo "INCIDENT_HOST: $INCIDENT_HOST"
	echo "ACK_ON: $ACK_ON"
	echo "RESOLVED_OR_ESCALATED_ON: $RESOLVED_OR_ESCALATED_ON"

	echo "$INCIDENT_NUMBER|$INCIDENT_HOST|$ACK_ON|$RESOLVED_OR_ESCALATED_ON" >> $CSV_RESULT
	writeLine
	writeLine
	echo
	echo
}

function parseIncidentsIdList {
	INDEX=1
	while read p; do
		q=`sed $INDEX'q;d' $RESULT_INCIDENTS_NUMBER`
		echo "elapsing index: $INDEX, ID: $p"
		
		getSingleIncident $p
		
		echo "sleeping now.."
		sleep 3

		parseSingleIncidentNew $q
		echo "sleeping now.."
		sleep 3

		INDEX=$((INDEX + 1))
	done < $RESULT_INCIDENTS_ID
}


###########################################
# MAIN CONTROLLER - BEGIN

if [ "$1" = 'clean' ]; then
	writeLine
	clean
	writeLine
fi

if [ "$1" = 'getAll' ]; then
	writeLine
	getAllIncidentsNew
	writeLine
fi

if [ "$1" = 'parse' ]; then
	writeLine
	parseIncidentsIdList
	writeLine
fi


if [ "$1" = 'list' ]; then
	writeLine
	getAllIncidents
	writeLine
	sleep 3
	parseAllIncidents
	writeLine
fi

if [ "$1" = 'setup' ] && [ "$2" != '' ]; then
	writeLine
	case $2 in
	    'linux' )
			echo "linux setup"
			cp bck/jq.linux jq
	        ;;

	    'osx' )
			echo "osx setup"
			cp bck/jq.osx jq
	        ;;

	    'win' )
			echo "are you kidding me?"
	        ;;
	esac
	writeLine
fi

if [ "$1" = 'details' ] && [ "$2" != '' ]; then
	writeLine
	getSingleIncident $2
	writeLine
	sleep 3
	parseSingleIncident
	writeLine
fi

